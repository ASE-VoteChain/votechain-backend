package com.votechain.backend.blockchain.contract;

import io.reactivex.Flowable;
import io.reactivex.functions.Function;
import org.web3j.abi.EventEncoder;
import org.web3j.abi.FunctionReturnDecoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Bool;
import org.web3j.abi.datatypes.Event;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.Utf8String;
import org.web3j.abi.datatypes.generated.Uint256;
import org.web3j.crypto.Credentials;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameter;
import org.web3j.protocol.core.RemoteFunctionCall;
import org.web3j.protocol.core.methods.request.EthFilter;
import org.web3j.protocol.core.methods.response.BaseEventResponse;
import org.web3j.protocol.core.methods.response.Log;
import org.web3j.protocol.core.methods.response.TransactionReceipt;
import org.web3j.tuples.generated.Tuple6;
import org.web3j.tx.Contract;
import org.web3j.tx.TransactionManager;
import org.web3j.tx.gas.ContractGasProvider;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Autogenerated wrapper class for the VoteChain contract.
 */
public class VoteChainContract extends Contract {
    public static final String BINARY = ""; // Estrictamente hablando, deberíamos poner el bytecode completo aquí, pero para interactuar con un contrato desplegado no es necesario

    public static final String FUNC_VOTING_COUNTER = "votingCounter";
    public static final String FUNC_OWNER = "owner";
    public static final String FUNC_CREATE_VOTING = "createVoting";
    public static final String FUNC_CAST_VOTE = "castVote";
    public static final String FUNC_VERIFY_VOTE = "verifyVote";
    public static final String FUNC_SET_VOTING_STATUS = "setVotingStatus";
    public static final String FUNC_USER_HAS_VOTED = "userHasVoted";
    public static final String FUNC_VOTING_EXISTS = "votingExists";
    public static final String FUNC_CHECK_VOTING_EXISTS = "checkVotingExists";
    public static final String FUNC_GET_VOTING_DETAILS = "getVotingDetails";
    public static final String FUNC_GET_OPTION_VOTE_COUNT = "getOptionVoteCount";
    public static final String FUNC_IS_VOTING_TIME_ENDED = "isVotingTimeEnded";
    public static final String FUNC_CLOSE_EXPIRED_VOTINGS = "closeExpiredVotings";

    public static final Event VOTING_CREATED_EVENT = new Event("VotingCreated",
            Arrays.asList(new TypeReference<Uint256>(true) {},
                          new TypeReference<Utf8String>() {},
                          new TypeReference<Address>() {}));

    public static final Event VOTE_CAST_EVENT = new Event("VoteCast",
            Arrays.asList(new TypeReference<Uint256>(true) {},
                          new TypeReference<Uint256>(true) {},
                          new TypeReference<Uint256>(true) {},
                          new TypeReference<Utf8String>() {}));

    public static final Event VOTING_STATUS_CHANGED_EVENT = new Event("VotingStatusChanged",
            Arrays.asList(new TypeReference<Uint256>(true) {},
                          new TypeReference<Bool>() {}));

    @Deprecated
    protected VoteChainContract(String contractAddress, Web3j web3j, Credentials credentials, BigInteger gasPrice, BigInteger gasLimit) {
        super(BINARY, contractAddress, web3j, credentials, gasPrice, gasLimit);
    }

    protected VoteChainContract(String contractAddress, Web3j web3j, Credentials credentials, ContractGasProvider contractGasProvider) {
        super(BINARY, contractAddress, web3j, credentials, contractGasProvider);
    }

    @Deprecated
    protected VoteChainContract(String contractAddress, Web3j web3j, TransactionManager transactionManager, BigInteger gasPrice, BigInteger gasLimit) {
        super(BINARY, contractAddress, web3j, transactionManager, gasPrice, gasLimit);
    }

    protected VoteChainContract(String contractAddress, Web3j web3j, TransactionManager transactionManager, ContractGasProvider contractGasProvider) {
        super(BINARY, contractAddress, web3j, transactionManager, contractGasProvider);
    }

    public RemoteFunctionCall<BigInteger> votingCounter() {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(FUNC_VOTING_COUNTER,
                Collections.emptyList(),
                Collections.singletonList(new TypeReference<Uint256>() {}));
        return executeRemoteCallSingleValueReturn(function, BigInteger.class);
    }

    public RemoteFunctionCall<String> owner() {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(FUNC_OWNER,
                Collections.emptyList(),
                Collections.singletonList(new TypeReference<Address>() {}));
        return executeRemoteCallSingleValueReturn(function, String.class);
    }

    public RemoteFunctionCall<TransactionReceipt> createVoting(String title, BigInteger startTime, BigInteger endTime) {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
                FUNC_CREATE_VOTING,
                Arrays.asList(new Utf8String(title),
                        new Uint256(startTime),
                        new Uint256(endTime)),
                Collections.emptyList());
        return executeRemoteCallTransaction(function);
    }

    public RemoteFunctionCall<TransactionReceipt> castVote(BigInteger votingId, BigInteger userId, BigInteger optionId, String voteHash) {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
                FUNC_CAST_VOTE,
                Arrays.asList(new Uint256(votingId),
                        new Uint256(userId),
                        new Uint256(optionId),
                        new Utf8String(voteHash)),
                Collections.emptyList());
        return executeRemoteCallTransaction(function);
    }

    public RemoteFunctionCall<List<Type>> verifyVote(String voteHash) {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
                FUNC_VERIFY_VOTE,
                Collections.singletonList(new Utf8String(voteHash)),
                Arrays.asList(
                        new TypeReference<Bool>() {},
                        new TypeReference<Uint256>() {},
                        new TypeReference<Uint256>() {},
                        new TypeReference<Uint256>() {}));
        return executeRemoteCallMultipleValueReturn(function);
    }

    public RemoteFunctionCall<TransactionReceipt> setVotingStatus(BigInteger votingId, Boolean active) {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
                FUNC_SET_VOTING_STATUS,
                Arrays.asList(new Uint256(votingId),
                        new Bool(active)),
                Collections.emptyList());
        return executeRemoteCallTransaction(function);
    }

    public RemoteFunctionCall<Boolean> userHasVoted(BigInteger votingId, BigInteger userId) {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
                FUNC_USER_HAS_VOTED,
                Arrays.asList(new Uint256(votingId),
                        new Uint256(userId)),
                Collections.singletonList(new TypeReference<Bool>() {}));
        return executeRemoteCallSingleValueReturn(function, Boolean.class);
    }

    /**
     * Verifica si una votación existe en la blockchain
     * Este método simplificado solo consulta si la votación existe
     */
    public RemoteFunctionCall<Boolean> votingExists(BigInteger votingId) {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
                FUNC_VOTING_EXISTS,
                Collections.singletonList(new Uint256(votingId)),
                Collections.singletonList(new TypeReference<Bool>() {}));

        return executeRemoteCallSingleValueReturn(function, Boolean.class);
    }

    /**
     * Verifica si una votación existe usando el método checkVotingExists del contrato
     */
    public RemoteFunctionCall<Boolean> checkVotingExists(BigInteger votingId) {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
                FUNC_CHECK_VOTING_EXISTS,
                Collections.singletonList(new Uint256(votingId)),
                Collections.singletonList(new TypeReference<Bool>() {}));

        return executeRemoteCallSingleValueReturn(function, Boolean.class);
    }

    /**
     * Obtiene los detalles completos de una votación
     */
    public RemoteFunctionCall<List<Type>> getVotingDetails(BigInteger votingId) {
        final org.web3j.abi.datatypes.Function function = new org.web3j.abi.datatypes.Function(
                FUNC_GET_VOTING_DETAILS,
                Collections.singletonList(new Uint256(votingId)),
                Arrays.asList(
                        new TypeReference<Utf8String>() {},   // title
                        new TypeReference<Uint256>() {},      // startTime
                        new TypeReference<Uint256>() {},      // endTime
                        new TypeReference<Bool>() {},         // active
                        new TypeReference<Address>() {},      // creator
                        new TypeReference<Uint256>() {}       // totalVotes
                ));
        return executeRemoteCallMultipleValueReturn(function);
    }

    public List<VotingCreatedEventResponse> getVotingCreatedEvents(TransactionReceipt transactionReceipt) {
        List<Contract.EventValuesWithLog> valueList = extractEventParametersWithLog(VOTING_CREATED_EVENT, transactionReceipt);
        ArrayList<VotingCreatedEventResponse> responses = new ArrayList<>(valueList.size());
        for (EventValuesWithLog eventValues : valueList) {
            VotingCreatedEventResponse typedResponse = new VotingCreatedEventResponse();
            typedResponse.log = eventValues.getLog();
            typedResponse.votingId = (BigInteger) eventValues.getIndexedValues().get(0).getValue();
            typedResponse.title = (String) eventValues.getNonIndexedValues().get(0).getValue();
            typedResponse.creator = (String) eventValues.getNonIndexedValues().get(1).getValue();
            responses.add(typedResponse);
        }
        return responses;
    }

    public Flowable<VotingCreatedEventResponse> votingCreatedEventFlowable(EthFilter filter) {
        return web3j.ethLogFlowable(filter).map(new Function<Log, VotingCreatedEventResponse>() {
            @Override
            public VotingCreatedEventResponse apply(Log log) {
                EventValuesWithLog eventValues = extractEventParametersWithLog(VOTING_CREATED_EVENT, log);
                VotingCreatedEventResponse typedResponse = new VotingCreatedEventResponse();
                typedResponse.log = log;
                typedResponse.votingId = (BigInteger) eventValues.getIndexedValues().get(0).getValue();
                typedResponse.title = (String) eventValues.getNonIndexedValues().get(0).getValue();
                typedResponse.creator = (String) eventValues.getNonIndexedValues().get(1).getValue();
                return typedResponse;
            }
        });
    }

    public Flowable<VotingCreatedEventResponse> votingCreatedEventFlowable(DefaultBlockParameter startBlock, DefaultBlockParameter endBlock) {
        EthFilter filter = new EthFilter(startBlock, endBlock, getContractAddress());
        filter.addSingleTopic(EventEncoder.encode(VOTING_CREATED_EVENT));
        return votingCreatedEventFlowable(filter);
    }

    public List<VoteCastEventResponse> getVoteCastEvents(TransactionReceipt transactionReceipt) {
        List<Contract.EventValuesWithLog> valueList = extractEventParametersWithLog(VOTE_CAST_EVENT, transactionReceipt);
        ArrayList<VoteCastEventResponse> responses = new ArrayList<>(valueList.size());
        for (EventValuesWithLog eventValues : valueList) {
            VoteCastEventResponse typedResponse = new VoteCastEventResponse();
            typedResponse.log = eventValues.getLog();
            typedResponse.votingId = (BigInteger) eventValues.getIndexedValues().get(0).getValue();
            typedResponse.userId = (BigInteger) eventValues.getIndexedValues().get(1).getValue();
            typedResponse.optionId = (BigInteger) eventValues.getIndexedValues().get(2).getValue();
            typedResponse.voteHash = (String) eventValues.getNonIndexedValues().get(0).getValue();
            responses.add(typedResponse);
        }
        return responses;
    }

    public Flowable<VoteCastEventResponse> voteCastEventFlowable(EthFilter filter) {
        return web3j.ethLogFlowable(filter).map(new Function<Log, VoteCastEventResponse>() {
            @Override
            public VoteCastEventResponse apply(Log log) {
                EventValuesWithLog eventValues = extractEventParametersWithLog(VOTE_CAST_EVENT, log);
                VoteCastEventResponse typedResponse = new VoteCastEventResponse();
                typedResponse.log = log;
                typedResponse.votingId = (BigInteger) eventValues.getIndexedValues().get(0).getValue();
                typedResponse.userId = (BigInteger) eventValues.getIndexedValues().get(1).getValue();
                typedResponse.optionId = (BigInteger) eventValues.getIndexedValues().get(2).getValue();
                typedResponse.voteHash = (String) eventValues.getNonIndexedValues().get(0).getValue();
                return typedResponse;
            }
        });
    }

    public Flowable<VoteCastEventResponse> voteCastEventFlowable(DefaultBlockParameter startBlock, DefaultBlockParameter endBlock) {
        EthFilter filter = new EthFilter(startBlock, endBlock, getContractAddress());
        filter.addSingleTopic(EventEncoder.encode(VOTE_CAST_EVENT));
        return voteCastEventFlowable(filter);
    }

    public List<VotingStatusChangedEventResponse> getVotingStatusChangedEvents(TransactionReceipt transactionReceipt) {
        List<Contract.EventValuesWithLog> valueList = extractEventParametersWithLog(VOTING_STATUS_CHANGED_EVENT, transactionReceipt);
        ArrayList<VotingStatusChangedEventResponse> responses = new ArrayList<>(valueList.size());
        for (EventValuesWithLog eventValues : valueList) {
            VotingStatusChangedEventResponse typedResponse = new VotingStatusChangedEventResponse();
            typedResponse.log = eventValues.getLog();
            typedResponse.votingId = (BigInteger) eventValues.getIndexedValues().get(0).getValue();
            typedResponse.active = (Boolean) eventValues.getNonIndexedValues().get(0).getValue();
            responses.add(typedResponse);
        }
        return responses;
    }

    public Flowable<VotingStatusChangedEventResponse> votingStatusChangedEventFlowable(EthFilter filter) {
        return web3j.ethLogFlowable(filter).map(new Function<Log, VotingStatusChangedEventResponse>() {
            @Override
            public VotingStatusChangedEventResponse apply(Log log) {
                EventValuesWithLog eventValues = extractEventParametersWithLog(VOTING_STATUS_CHANGED_EVENT, log);
                VotingStatusChangedEventResponse typedResponse = new VotingStatusChangedEventResponse();
                typedResponse.log = log;
                typedResponse.votingId = (BigInteger) eventValues.getIndexedValues().get(0).getValue();
                typedResponse.active = (Boolean) eventValues.getNonIndexedValues().get(0).getValue();
                return typedResponse;
            }
        });
    }

    public Flowable<VotingStatusChangedEventResponse> votingStatusChangedEventFlowable(DefaultBlockParameter startBlock, DefaultBlockParameter endBlock) {
        EthFilter filter = new EthFilter(startBlock, endBlock, getContractAddress());
        filter.addSingleTopic(EventEncoder.encode(VOTING_STATUS_CHANGED_EVENT));
        return votingStatusChangedEventFlowable(filter);
    }

    /**
     * Load a deployed VoteChainContract
     * @param contractAddress the address of the contract
     * @param web3j web3j connection
     * @param credentials wallet credentials
     * @param gasPrice gas price
     * @param gasLimit gas limit
     * @return the loaded contract
     */
    public static VoteChainContract load(String contractAddress, Web3j web3j, Credentials credentials, BigInteger gasPrice, BigInteger gasLimit) {
        return new VoteChainContract(contractAddress, web3j, credentials, gasPrice, gasLimit);
    }

    /**
     * Load a deployed VoteChainContract
     * @param contractAddress the address of the contract
     * @param web3j web3j connection
     * @param credentials wallet credentials
     * @param contractGasProvider gas provider
     * @return the loaded contract
     */
    public static VoteChainContract load(String contractAddress, Web3j web3j, Credentials credentials, ContractGasProvider contractGasProvider) {
        return new VoteChainContract(contractAddress, web3j, credentials, contractGasProvider);
    }

    /**
     * Load a deployed VoteChainContract
     * @param contractAddress the address of the contract
     * @param web3j web3j connection
     * @param transactionManager transaction manager
     * @param contractGasProvider gas provider
     * @return the loaded contract
     */
    public static VoteChainContract load(String contractAddress, Web3j web3j, TransactionManager transactionManager, ContractGasProvider contractGasProvider) {
        return new VoteChainContract(contractAddress, web3j, transactionManager, contractGasProvider);
    }

    public static class VotingCreatedEventResponse extends BaseEventResponse {
        public BigInteger votingId;
        public String title;
        public String creator;
    }

    public static class VoteCastEventResponse extends BaseEventResponse {
        public BigInteger votingId;
        public BigInteger userId;
        public BigInteger optionId;
        public String voteHash;
    }

    public static class VotingStatusChangedEventResponse extends BaseEventResponse {
        public BigInteger votingId;
        public Boolean active;
    }
}
